services:
  midi-converter:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: midi-to-audio-converter
    restart: unless-stopped

    # Volumes for persistence
    volumes:
      # Configuration (.env file is read by dotenv in the application)
      - ./config/.env:/app/.env:ro

      # Debugging & Development (mount source code and debug scripts)
      - ./src:/app/src
      - ./debug-tcp.sh:/app/debug-tcp.sh:ro
      - ./debug-container.sh:/app/debug-container.sh:ro

      # Output directory for generated MP3s
      - ./data/output:/app/output

      # Soundfont storage
      - ./data/soundfonts:/app/soundfonts:ro

      # Logs
      - ./data/logs:/app/logs

      # Temporary files (optional, can use tmpfs for performance)
      - temp-data:/app/temp

    # Resource limits (Optimized for 8 CPU / 32GB RAM Host)
    deploy:
      resources:
        limits:
          cpus: '7' # Allow nearly full CPU usage (leave 0.5 for OS)
          memory: 14G # Generous limit (system has 32GB)
        reservations:
          cpus: '6' # Guarantee 1 core per process
          memory: 12G # Guarantee plenty of RAM

    # Network configuration (if MongoDB is in same compose)
    networks:
      - midi-network

    # Logging configuration
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

    # Start processing (concurrency controlled by .env, default 4)
    command: [ "node", "src/index.js" ]
    # Named volumes
volumes:
  temp-data:
    driver: local

# Optional: if MongoDB runs in same stack
networks:
  midi-network:
    driver: bridge
